// システム設定初期化
g1=640 g2=580	// 画面サイズ
GSg1,g2;		// 画面サイズ設定
//SM1;			// BGM0番を再生
GW33;			// 速度ウエイト

// 画像描画(c1:x軸, c2:y軸, c3:画像番号)
// IN: @ポインタにc構造体の先頭を入れておくこと
#0{
    x=@ y=@(1   // 座標を取得
    G@(2,x,y;		// 描画
}

// オセロ版のd番目(昇順0始まり)の位置のx,y座標を計算する
// IN: eにマス番号を入れておくこと
#1{
	x=CC(e%8*d1)+(e%8*d2)+d3; y=CC(e/8*d1)+(e/8*d2)+d4;
}

// 選択された画像に縁取りをつける
// IN: @ポインタにc構造体の先頭を入れておくこと
#2{
	GA70; a=4 // a:枠縁のサイズ
	r=100 g=200 b=150 x=@ y=@(1 x1=@(3 y1=@(4
	x-a y-a x1=CCx1+(a*2)+1; y1=CCy1+(a*2)+1; GB; // a*2はスクエア。+1は微調整。
	GA100;
}

// 周囲のマス状況を取得 r1~9:左上から1~9で表記
// IN: eにマス番号を入れておくこと
//     mに全マスのコマ情報を入れておくこと
#3{
	// b1~b9に周囲のマス番号を格納
	i=9 [b(i=e i-1 i] // 基準点格納
	b1-9 b2-8 b3-7
	b4-1 b5=e b6+1
	b7+7 b8+8 b9+9

	// 周囲のマス情報を格納
	r1=m(b1 r2=m(b2 r3=m(b3
	r4=m(b4 r5=m(b5 r6=m(b6
	r7=m(b7 r8=m(b8 r9=m(b9

	// オーバーフローチェック（存在しないマスに3を格納）
	// x軸の割り出し x=b%8	
	// y軸の割り出し y=b/8
	b10=CC(e%8)==1; b10[r1=3 r4=3 r7=3]		// x1(左端)
	b10=CC(e%8)==0; b10[r3=3 r6=3 r9=3]		// x9(右端)
	b10=CC(e-1)/8==0; b10[r1=3 r2=3 r3=3]	// y1(上端)
	b10=CC(e-1)/8==7; b10[r7=3 r8=3 r9=3]	// y9(下端)
}

// （#6再帰用）指定方位のマス状況を取得
// IN: eにマス番号, e1に1~9の方位を入れておくこと
#4{
	// b1~b9に周囲のマス番号を格納
	i1=9 [b(i1=e i1-1 i1] // 基準点格納
	b1-9 b2-8 b3-7
	b4-1 b5=e b6+1
	b7+7 b8+8 b9+9

	// 指定方向のマスを取得
	e=b(e1;
	a=CCm(e==k; a[#4][			// 相手のコマがあれば再帰
		a1=CCm(e==c; a1[i1=1 e2=e e=a9 m(e=4 ] // その後自分のコマがあれば置ける
	]
}


// コマを指定色に変える
#5{
	// b1~b9に周囲のマス番号を格納
	i1=9 [b(i1=e i1-1 i1] // 基準点格納
	b1-9 b2-8 b3-7
	b4-1 b5=e b6+1
	b7+7 b8+8 b9+9
	
	e=b(e1
	b=e b-1 b*6 b+6 c(b=c
	a=CCe!=e2; a[#5]
}

// コマを置けるかをm(b=4でセット
// IN: mに全マスのコマ情報を入れておくこと
// #3 IN: eにマス番号を入れておくこと
#6{
	#3;						// １マスの周囲をチェック
	a=CC(r5==0)&&(r5!=3);	// 空白(0)マスである && 壁(3)以外の時
	a[
		// 相手のコマ(k)があるか確認
		a1=CCc==1; a1[k=2][k=1]
		i=9 [
			i1=0			// 複数方向コマ判定用
			a1=CCr(i==k;	// 相手のコマがあれば、
			a1[
				a9=e		// #4再帰のため一時退避
				e1=i #4;	// 方位e1をセットして再帰チェック
				a2=CCi1==1; a2[
					#5		// 色塗り
					a3=CCc==1; a3[S4;][S1;]
				]
				e=a9		// 復帰
			]
		i-1 i]
	]
}

///////////////////////////////////////
// C構造体 c:白１の手番、黒２の手番を表す
// @(0:x座標, @(1:y座標, @(2:画像番号, @(3:画像縦サイズ,
// @(4:画像横サイズ, @(5:コマ無0, 白1, 黒2, 壁3, 配置可4
///////////////////////////////////////
// フィールド(d1:画像サイズ, d2:隙間サイズ, d3d4:フィールドx,yオフセット)
c=0 @:c1 d1=56 d2=5 d3=80 d4=40
a=64 [
	// b:昇順Noから描画位置を求める
	e=CC(64-a); #1;
	@=x @(1=y @(2=0 @(3=d1 @(4=d1 @(5=0
	@>6	// 次のマスへ
	a-1 // ループカウントダウン
a];

// オセロ初期セット
e=27 e*6 @:c1 @>e @(5=1 // 白
e=36 e*6 @:c1 @>e @(5=1 // 白
e=28 e*6 @:c1 @>e @(5=2 // 黒
e=35 e*6 @:c1 @>e @(5=2 // 黒

c=2	// 手番を黒へセット
u=1 // チャタリング制御（アンロック）

// ゲーム開始
z=1 [
    GC;
	
	//マウスカーソルの縁取りを描画
	x2=KMX; y2=KMY;	// カーソル位置を取得
	@:c1			// マスの開始位置
	n=64 [			// 画像数でループ
		a=CHx2,y2,@,@(1,@(3,@(4;

		// ※※※※※※※※※※※※※※
		// ※デバッグ用※
		a[e=CC65-n; #3; b11=e]
		GT570,30,"p ="; GT600,30,b11;
		// ※※※※※※※※※※※※※※
		
		// 縁取り表示、ループ終了。
		a[
			#2; n1=n n=0	// #2:@に依存
		][
			@>6 n-1			// 次のマスへ
		]
	n]
	
	a[
		// マウス左クリック
		a1=KML; a1[
			u[	// チャタリング制御(ロック)
				u=0
				// 配置可能なら手番の色をセット
				e=CC65-n1; #6;
				a1=CCm(e==4; a1[
					// コマを置く
					@(5=c
					// クリックされたら手番交代
					a2=CCc==1; a2[c=2][c=1]
				]
			]
		][
			u=1	// チャタリング制御(アンロック)
		]	
	]

	// @を設定し、関数で全画像を描画
	i=1 n=64 [
		@:c(i #0
		// マスに設定されているコマを描画
		b1=@(5 
		a=CCb1==1; a[e=CC64-n; #1; G1,x,y;]	// #1:eに依存 
		a=CCb1==2; a[e=CC64-n; #1; G2,x,y;]

		// マスに設定されているコマを取得
		b2=CC65-n; m(b2=b1	// m:１始まりの盤面保持情報

		i+6
	n-1 n]

	// マウスカーソルの座標を取得
	x=KMX; y=KMY; G110;

	// ソナー（スペース）
	k=KSp; k[SS4;]
	
	// 終了キー（Esc）判定
	k=KEs; k[z=0]

	// タイムカウント
	t+1 b=t b>31 b[
		t=1 t1+1
	]
	
	// デバッグ用テキスト
	GT570,10,"c ="; GT600,10,c;
	GT570,50,"t1="; GT600,50,t1;
	GT570,70,"u ="; GT600,70,u;
	
	GT570,90,"r1="; GT600,90,r1;
	GT570,110,"r2="; GT600,110,r2;
	GT570,130,"r3="; GT600,130,r3;
	GT570,150,"r4="; GT600,150,r4;
	GT570,170,"r5="; GT600,170,r5;
	GT570,190,"r6="; GT600,190,r6;
	GT570,210,"r7="; GT600,210,r7;
	GT570,230,"r8="; GT600,230,r8;
	GT570,250,"r9="; GT600,250,r9;

	GT570,290,"k ="; GT600,290,k;
	GT570,310,"e3="; GT600,310,e3;
	
    // 画面出力（FLIP）
    GF;
z]


@:m
F0; FW64; FC;