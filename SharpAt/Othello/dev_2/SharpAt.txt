// システム設定初期化
//g1=640 g2=580	// 画面サイズ
g1=1100 g2=680	// デバッグ画面サイズ
GSg1,g2;		// 画面サイズ設定
//SM1;			// BGM0番を再生
GW33;			// 速度ウエイト

// 画像描画
// IN: @ポインタにc構造体の先頭を入れておくこと
#0{
	x=@(1 y=@(2
    G@,x,y;		// 描画
}
// オセロ版のe番目の位置のx,y座標を計算する
#1{
	// (e1:画像サイズ, e2:隙間サイズ, e3e4:x,yオフセット)
	e1=56 e2=5 e3=80 e4=40
	a1=e a1-1
	x=CC(a1%8*e1)+(a1%8*e2)+e3; y=CC(a1/8*e1)+(a1/8*e2)+e4;
}

// カーソル下のマスに縁取りをつける
#4{
	GA60;
	x=@(1 y=@(2 x1=@(3 y1=@(4
	x-a4 y-a4 x1=CCx1+(a4*2)+1; y1=CCy1+(a4*2)+1; GB; // a4*2はスクエア。+1は微調整
	GA100;
}
// 指定マスeの周囲の状態を調べる
#5{
	// b1~b9に周囲のマス番号を格納
	i5=9 [d(i5=e i5-1 i5] // 基準点
	d7-9 d8-8 d9-7
	d4-1 d5=e d6+1
	d1+7 d2+8 d3+9

	// 周囲のコマ情報を格納
	f7=m(d7 f8=m(d8	f9=m(d9
	f4=m(d4 f5=m(d5 f6=m(d6
	f1=m(d1 f2=m(d2 f3=m(d3

	// オーバーフローチェック（存在しないマスに9を格納）
	// x軸の割り出し x=b%8
	b5=CC(e%8)==1; b5[f7=9 f4=9 f1=9]	// x1(左端)
	b5=CC(e%8)==0; b5[f9=9 f6=9 f3=9]	// x9(右端)
	b5=CC(0<e)&&(e<9); b5[f7=9 f8=9 f9=9]	// y1(上端)
	b5=CC(56<e)&&(e<65); b5[f1=9 f2=9 f3=9]	// y9(下端)
}
// （再帰）指定マスeと指定方向e1の状態を元に取得コマ数を調べる
#6{
	#5;						// 周囲探索
	b=CCf(e1!=9; b[			// 壁ならスキップ
		e=d(e1;				// 指定方向のマス番号を取得
		b1=CCc==1; b1[
			// 黒側探索
			b4=CCf(e1==2; b4[a6+1 #6;][			// 相手のコマがあればカウントして再帰
				b6=CCf(e1==1; b6[r+a6][a6=0]	// 先に自分のコマがあればカウントアップ
			]
		][
			// 白側探索
			b4=CCf(e1==1; b4[a6+1 #6;][			// 相手のコマがあればカウントして再帰
				b6=CCf(e1==2; b6[r+a6][a6=0]	// 先に自分のコマがあればカウントアップ
			]
		]
	][a6=0]
}

// 指定マスeに置いた時、何マス取れるかを調べる
#7{
	// 周囲マス番号d9~d1(テンキー配列)
	// 周囲マス探索r9~r1(テンキー配列)
	#5;

	// 全方位チェック
	r=0 // カウント初期化、
	i7=9 [
		e1=i7			// 方位セット
		b=CCe1!=5; b[	// 中心部は除外	
			a7=e		// 再帰のため一時退避
			a6=0 #6;	// チェック
			e=a7		// 復帰
		]
	i7-1 i7]
}

// 指定マスeにcの色のコマを置く
#8{
	m(e=c
	b8=CCc==1; b8[S1;][S4;]
}

// 指定マスeに置き、獲得可能なマスを塗りつぶす
// 塗り潰しの設計間違っててどうしようもなくなったので、ゴリ押し実装
#9{
	// 一時的にc書き換え
	a9=c c=v
	// eにコマを配置
	#8;

	// 全方位チェック
	r=0
	i9=9 [
		e1=i9			// 方位セット
		b=CCe1!=5; b[	// 中心部は除外
		
			a10=e		// 再帰のため一時退避
			a6=0 #6;	// チェック
			e=a10		// 復帰

			// 配置場所から方位へ取得分塗り替える
			b1=CCa6>0; b1[
				i10=a6 [
					// 周囲探索
					#5;
					a11=d(e1
					// 壁(9)じゃなければ塗り替え
					b2=CCf(e1!=9; b2[e=a11 #8;]

				i10-1 i10]
			]
			// eを再度戻す
			e=a10
		]	
	i9-1 i9]

	// c書き戻し
	c=a9;
}

// 黒１と白２のターンｃチェンジ
#10{
	a10=CCc==1; a10[c=2][c=1]
}


// タイトル画面
// 黒と白どちらかを選択、決定
z=1 [

	z1=1 [
		GC;
		//D"タイトル";

		// チャタリング初期化
		u=1



		// p0プレイヤーの色の決定
		p=1;
		// p1相手のコマの決定
		a=CCp==1; a[p1=2][p1=1]

		// 難易度の選択
			// L1：ランダムに配置
			// L2：角・端を意識した配置
			// L3：開発者と対戦する。L2＋相手の選択数を狭める配置

		// タイムリミットの設定

		z1=0
	z1]

	// 残像初期数値
	a=5 

	///////////////////////////////////////
	// C構造体 c0:黒１白２
	// [c1:画像番号, c2:x座標, c3:y座標, c4:縦サイズ, c5:横サイズ]
	///////////////////////////////////////
	// フィールド初期化開始
	i=1 @:c1
	z2=1 [
		// 残像処理	
		a+1 GAa; GC;
		// c構造体に64マスの画像を設定
		e=i	#1	
		@=0 @(1=x @(2=y @(3=e1 @(4=e1
		i+1 @>5
		// 盤面を描画
		@:c1 n=i n-1 [#0 @>5 n-1 n]
		// ループ終了
		b=CCi>64; b[z2=0]
		GF;
	z2]

	// 盤面初期化
	//D"ゲーム開始";
	GA100;	// 残像処理解除・暗転
	// コマ配置初期化
	c=2 e=28 #8; e=37 #8;
	// 先行ターンを黒へ(c=1)
	c=1 e=29 #8; e=36 #8;
	v=c;	// ターンチェンジ感知（直前の色）
	v1=0;	// ターンチェンジフラグ
	v2=0;	// 直前にコマが配置された場所
	v3=0;	// どちらもおけなくなるカウント（カウント２で判定）
	t2=16;	// NPCwait数（初期値２）
	t3=t2;	// NPCwaitカウント用
	// ゲーム開始
	z3=1 [
		GC;


		// ターン切り替わり感知
		b=CCv!=c; b[
			e=v2
			v=c v1=1
			GA10;
		][
			GA100;
			v1=0
		]

		// ゲーム判定



		// 入力可能箇所の探索 #7
		j=0 l=0
		i=1 n=64 [
			// マス目初期化
			b3=CCc==1; b3[j(i=0][l(i=0]
			
			// マス番号セット
			e=i	

			// 空白マスチェック
			b1=CCm(i==0; b1[	
				#7;
				b2=CCr>0; b2[
					b3=CCc==1; b3[j(i=r j+1][l(i=r l+1]
				]
			]
		i+1 n-1 n]


		b=CCc==p; b[
			// プレイヤー入力受付
			k=KML; k[
				u[	
					u=0				// チャタロック
					x=KMX; y=KMY;	// カーソル位置を取得
					@:c1 n=64 [
						a=CC65-n;
						// 配置可能な場所かチェック(現在のターンの色で)
						b1=CCc==p; b1[
							// 黒
							b2=CCj(a>0; b2[
								b=CHx,y,@(1,@(2,@(3,@(4; b[
									e=a #8;	// コマをセット
									#9; 	// コマ塗り替え
									#10;	// ターンチェンジ
									v2=0;	// NPCの置いた場所をリセット
									n=1;	// ループ終了
								]
							]
						][	// 白
							b2=CCl(a>0; b2[
								b=CHx,y,@(1,@(2,@(3,@(4; b[
									e=a #8;	// コマをセット
									#9; 	// コマ塗り替え
									#10;	// ターンチェンジ
									v2=0;	// NPCの置いた場所をリセット
									n=1;	// ループ終了
								]
							]
						]
						@>5 n-1	// 次のマスへ
					n]
				]
			][
				u=1		// チャタアンロック
				b1=CCc==p; b1[
					// 黒
					b2=CCj==0; b2[
						D"置く場所がありません…";
						v3+1;
						#10;
					]
				][	// 白
					b2=CCl==0; b2[
						D"置く場所がありません…";
						v3+1;
						#10;
					]
				]
			]
		][
			// すぐ切り替わると混乱するからwait
			b=CCt3==0; b[
				// NPC
				b=CCp==1; b[
					// 白
					b1=CCl!=0; b1[
						n=64 [
							a=CC65-n;
							b2=CCl(a>0; b2[e=a v2=a; #8; #9; #10; n=1]
						n-1 n]
					][
						// 配置不可時切り替え
						v3+1 #10;
					]
				][
					// 黒
					b1=CCj!=0; b1[
						n=64 [
							a=CC65-n;
							b2=CCj(a>0; b2[e=a v2=a; #8; #9; #10; n=1]
						n-1 n]
					][
						// 配置不可時切り替え
						v3+1 #10;
					]
				]
				// Waitリセット
				t3=t2
			][
				// 置く前に置く場所をプレイヤーへ伝えるアニメーション処理(時間が1/3になったら)
				b=CCt3<(t2/3); b[
					// 探索のみ
					b=CCp==1; b[
						b1=CCl!=0; b1[	// 白
							n=64 [
								a=CC65-n;
								b2=CCl(a>0; b2[e=a v2=a;n=1]
							n-1 n]
						]
						t2=CC(l*3);	// 選択分だけWaitしてみる
					][	
						b1=CCj!=0; b1[	// 黒
							n=64 [
								a=CC65-n;
								b2=CCj(a>0; b2[e=a v2=a;n=1]
							n-1 n]
						]
						t2=CC(j*3);	// 選択分だけWaitしてみる
					]
				]
				// Waitカウントダウン
				t3-1;
			]
			
		]
		
		// 直前に置かれた場所を表示
		@:c1 n=64 [
			a=CC65-n;
			b=CCa==v2;
			b[r=250 g=80 b=80 a4=3 #4;]
		@>5 n-1 n]

		// ゲーム終了チェック
		b=CCv3>2; b[
			// 手番保持
			a=c

			// 黒白の配置可能数初期化
			j=0 l=0

			// 黒チェック (最初の探査処理と同じ)
			c=1 i=1 n=64 [
				b3=CCc==1; b3[j(i=0][l(i=0]
				e=i	
				b1=CCm(i==0; b1[	// 空白マスチェック
					#7; b2=CCr>0; b2[j(i=r j+1]
				]
			i+1 n-1 n]

			// 白チェック
			c=2 i=1 n=64 [
				b3=CCc==1; b3[j(i=0][l(i=0]
				e=i	
				b1=CCm(i==0; b1[	// 空白マスチェック
					#7; b2=CCr>0; b2[l(i=r l+1]
				]
			i+1 n-1 n]

			b1=CC(j==0)&&(l==0); b1[z3=0][c=a]
		]


		// マウスカーソル下のマス縁取りを描画
		x=KMX; y=KMY;		// カーソル位置を取得
		@:c1 n=64 [			// マス数でループ
			b=CHx,y,@(1,@(2,@(3,@(4;
			b[
				// 縁取りしてループ終了
				r=130 g=230 b=180 a4=4 #4;	// a4:枠縁のサイズ
				n1=CC65-n; n=0
				e=n1 #5;
			][
				@>5 n-1		// 次のマスへ
			]
		n]

		// 手番の色の入力可能場所を表示
		@:c1 n=64 [
			a=CC65-n;
			b=CCc==1;
			b[	// 黒色
				// １マスでも取れるなら縁取り
				b1=CCj(a>0;
				b1[r=230 g=230 b=180 a4=2 #4;]	// a4:枠縁のサイズ
			][	// 白色
				// １マスでも取れるなら縁取り
				b1=CCl(a>0;
				b1[r=230 g=230 b=180 a4=2 #4;]	// a4:枠縁のサイズ
			]
		@>5 n-1 n]

		// マスを描画
		@:c1 n=64 [
			#0; @>5
		n-1 n]

		// コマを描画
		i=1 n=64 [
			b=CCm(i>0; b[
				e=i #1; Gm(i,x,y;
			]
		i+1 n-1 n]


		// マウスカーソルを描画
		x=KMX; y=KMY; G110;

		// スペースキー
		k=KSp; k[SS4;]
		
		// 終了キー（Esc）
		k=KEs; k[z=0]

		// タイムカウント
		t+1 b=t b>31 b[
			t=1 t1+1
		]
		
		// デバッグ用テキスト
		GT570,10,"c ="; GT610,10,c;
		GT570,30,"n1="; GT610,30,n1;
		GT570,50,"t1="; GT610,50,t1;
		GT570,70,"u ="; GT610,70,u;
		
		GT570,110,"f1="; GT610,110,f1;
		GT570,130,"f2="; GT610,130,f2;
		GT570,150,"f3="; GT610,150,f3;
		GT570,170,"f4="; GT610,170,f4;
		GT570,190,"f5="; GT610,190,f5;
		GT570,210,"f6="; GT610,210,f6;
		GT570,230,"f7="; GT610,230,f7;
		GT570,250,"f8="; GT610,250,f8;
		GT570,270,"f9="; GT610,270,f9;

		GT570,310,"t2="; GT610,310,t2;
		GT570,330,"t3="; GT610,330,t3;
		GT570,350,"j ="; GT610,350,j;
		GT570,370,"l ="; GT610,370,l;

		// 盤面デバッグ用
		x9=650 y9=10
		i=0 n=64 [
			a=i a+1
			GTx9,y9,"j"; x9+10 GTx9,y9,a; 
			a=CCi%8; x9+40; b=CCa==7; b[x9=650]
			a=CCi%8; b=CCa==7; b[y9+40]
			i+1
		n-1 n]
		x9=650 y9=25
		i=0 n=64 [
			a=i a+1
			x9+20 GTx9,y9,"="; x9+10 GTx9,y9,j(a;
			a=CCi%8; x9+20; b=CCa==7; b[x9=650]
			a=CCi%8; b=CCa==7; b[y9+40]
			i+1
		n-1 n]

		// 盤面デバッグ用
		x9=650 y9=360
		i=0 n=64 [
			a=i a+1
			GTx9,y9,"l"; x9+10 GTx9,y9,a; 
			a=CCi%8; x9+40; b=CCa==7; b[x9=650]
			a=CCi%8; b=CCa==7; b[y9+40]
			i+1
		n-1 n]
		x9=650 y9=375
		i=0 n=64 [
			a=i a+1
			x9+20 GTx9,y9,"="; x9+10 GTx9,y9,l(a;
			a=CCi%8; x9+20; b=CCa==7; b[x9=650]
			a=CCi%8; b=CCa==7; b[y9+40]
			i+1
		n-1 n]
		
		GF;	// 画面出力（FLIP）
	z3]


	// リザルト
	z4=1 [
		D"リザルト";
		// 盤面保存
		@:m
		F0; FW64; FC;
		z3=0
	z4]


z]
